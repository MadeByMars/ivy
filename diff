diff --git a/ivy/ivy_to_vmt.py b/ivy/ivy_to_vmt.py
index 79854ae..820188d 100644
--- a/ivy/ivy_to_vmt.py
+++ b/ivy/ivy_to_vmt.py
@@ -1,4 +1,5 @@
 import sys
+#sys.path.insert(0, "/home/rock/ws/version/github/aman_goel/latest/ivy/ivy")
 
 import ivy_logic
 import ivy_utils as iu
@@ -17,23 +18,21 @@ import ivy_utils as utl
 import ivy_compiler
 import ivy_isolate
 import ivy_ast
-from collections import defaultdict
 
-outF = sys.stdout
+outFile = "out.vmt"
+outF = None
 def fprint(s):
     global outF
     outF.write(s + "\n")
 
-#for cls in [lg.Eq, lg.Not, lg.And, lg.Or, lg.Implies, lg.Iff, lg.Ite, lg.ForAll, lg.Exists,
-#            lg.Apply, lg.Var, lg.Const, lg.Lambda, lg.NamedBinder, lg.EnumeratedSort, lg.Const]:
-#    if hasattr(cls,'__vmt__'):
-#        cls.__str__ = cls.__vmt__
+
+for cls in [lg.Eq, lg.Not, lg.And, lg.Or, lg.Implies, lg.Iff, lg.Ite, lg.ForAll, lg.Exists,
+            lg.Apply, lg.Var, lg.Const, lg.Lambda, lg.NamedBinder]:
+    if hasattr(cls,'__vmt__'):
+        cls.__str__ = cls.__vmt__
 
 class print_module_vmt():
-    def __init__(self, mod, inst):
-        self.instance = {}
-        self.concretizations = []
-        self.used = set()
+    def __init__(self, mod):
         self.mod = mod
         self.sorts = {}
         self.pre = set()
@@ -48,31 +47,12 @@ class print_module_vmt():
         self.helpers = {}
         self.definitions = set()
         self.defn_labels = []
-        self.prestr = {}
-        self.nexstr = {}
-        self.prenexstr = {}
+        self.defs = set()
+        self.str = {}
         self.vmt = {}
-        self.axioms = []
         self.prefix = "__"
-        self.read_instance(open(inst, 'r'))
         self.execute()
 
-    def read_instance(self, fi):
-        n = eval(fi.readline())
-        for i in range(n):
-            st = fi.readline().split('=')
-            self.instance[st[0]] = eval(st[1])
-        assert fi.readline() == '\n'
-        n = eval(fi.readline())
-        for i in range(n):
-            st = fi.readline()[:-1]
-            self.concretizations.append(st)
-            s = st.split('=')
-            if len(s) == 2:
-                self.axioms.append('(= %s %s)' % (s[0], s[1]))
-            else:
-                self.axioms.append("(= %s bv_true)" % (s[0]))
-
     def execute(self):
         if len(self.mod.labeled_props) != 0:
             print("labeled_props: %s" % str(self.mod.labeled_props))
@@ -84,15 +64,15 @@ class print_module_vmt():
             print("native_definitions: %s" % str(self.mod.native_definitions))
             assert(0)
         if len(self.mod.sig.interp) != 0:
-            print >> sys.stderr, "sig.interp: %s" % str(self.mod.sig.interp)
-#            assert(0)
+            print("sig.interp: %s" % str(self.mod.sig.interp))
+            assert(0)
 
         if len(self.mod.definitions) != 0:
 #             print("definitions: %s" % str(self.mod.definitions))
             for defn in self.mod.definitions:
                 self.definitions.add(defn)
             self.mod.definitions = []
-
+            
         with self.mod.theory_context():
             print >>sys.stderr, 'sig'
             self.process_sig()
@@ -106,112 +86,60 @@ class print_module_vmt():
             self.process_init()
             print >>sys.stderr, 'actions'
             self.process_actions()
-            print >>sys.stderr, 'done'
-#            self.process_guarantee()
+            self.process_global()
     
             self.print_vmt()
-            self.print_config()
-    
+            
     def print_vmt(self):
-        fprint(
-'''(set-info :source |Haojun Ma (mahaojun@umich.edu)|)
-
-; Typecast bit to bool
-(define-sort bool_type () (_ BitVec 1)) 
-(define-fun bv_false () bool_type (_ bv0 1)) 
-(define-fun bv_true  () bool_type (_ bv1 1)) 
-(define-fun is_bool ((x bool_type)) Bool (or (= x bv_true) (= x bv_false)))
-
-; Define and enumerate transition system parameters'''
-)
+        global outF, outFile
+        outF = open(outFile, 'w')
+        
+        for s in self.sorts.keys():
+            fprint(self.str[str(s)])
+        fprint("")
         for s, v in self.sorts.iteritems():
-            fprint('(define-sort %s_type () (_ BitVec %d))' % (s, v))
-            for i in range(self.instance[s]):
-                fprint('(define-fun %s%d () %s_type (_ bv%d %d))' % (s, i, s, i, v))
-            fprint('(define-fun is_%s ((%s %s_type)) Bool (or %s))'%(s, s, s, ' '.join(["(= %s %s%d)" % (s, s, i) for i in range(self.instance[s])])))
-        fprint("\n; Declare transition system states")
+            self.print_sort_size(str(s), v)
+        fprint("")
         for pre in self.pre:
-            fprint(self.prestr[pre.get_vmt()])
-        fprint("\n; Declare next states")
+            fprint(self.str[str(pre)])
+        fprint("")
         for pre in self.pre:
             nex = self.pre2nex[pre]
-            fprint(self.nexstr[nex.get_vmt()])
+            fprint(self.str[str(nex)])
         fprint("")
         for pre in self.pre:
             nex = self.pre2nex[pre]
-            fprint(self.prenexstr[pre.get_vmt() + nex.get_vmt()])
-# no global
-#        if len(self.glo) != 0:
-#            fprint("")
-#            for g in self.glo:
-#                fprint(self.str[str(g)])
-#            fprint("")
-#            for g in self.glo:
-#                pre = self.nex2pre[g]
-#                fprint(self.str[str(pre)+str(g)])
+            fprint(self.str[str(pre)+str(nex)])
+        fprint("")
+        if len(self.glo) != 0:
+            for g in self.glo:
+                fprint(self.str[str(g)])
+            fprint("")
+            for g in self.glo:
+                pre = self.nex2pre[g]
+                fprint(self.str[str(pre)+str(g)])
+            fprint("")
         if len(self.vars) != 0:
-            fprint("\n; Declare local variables")
             for v in self.vars:
-                fprint(self.nexstr[v.get_vmt()])
-#        for h in self.defn_labels:
-#            fprint("")
+                fprint(self.str[str(v)])
+            fprint("")
+        for h in self.defn_labels:
 #            fprint(self.get_vmt_string_def(h))
-#            fprint(self.get_vmt_string(h))
-        fprint("\n; Safety property")
+            fprint(self.get_vmt_string(h))
+            fprint("")
         fprint(self.get_vmt_string("$prop"))
-        fprint("\n; Declare axioms")
+        fprint("")
         if len(self.mod.labeled_axioms) != 0:
-            f, name, suffix, value = self.vmt["$axiom"]
-            fprint('(define-fun my_axioms () Bool\n(and %s\n%s)\n)' % (f.instantiation(self.instance, {}), ' '.join(self.axioms)))
-        else:
-            fprint('(define-fun my_axioms () Bool\n(and true\n%s)\n)' % (' '.join(self.axioms)))
-        fprint("\n; Declare initial states")
+            fprint(self.get_vmt_string("$axiom"))
+            fprint("")
         fprint(self.get_vmt_string("$init"))
-        fprint("\n; Declare actions")
+        fprint("")
         for actname in self.actions:
+            fprint(self.get_vmt_string(actname))
             fprint("")
-            fprint(self.vmt[actname])
+        for h in sorted(self.helpers.keys()):
+            fprint(self.get_vmt_string(h))
             fprint("")
-        copies = []
-        for var in self.nex:
-            copies += self.copy_constant(var)
-        fprint("(define-fun .trans () Bool (! (and (or %s \n(and %s))\n my_axioms) \n:trans true))"%(' '.join(self.actions), ' '.join(copies)))
-#        for h in sorted(self.helpers.keys()):
-#            fprint(self.get_vmt_string(h))
-#            fprint("")
-        
-    def print_config(self):
-        fo = open('config.txt', 'w')
-        if ivy_compiler.isolate.get():
-            st = sys.argv[1].split("_")
-            print>>fo, '_'.join(st[:-1])
-            print>>fo, 'isolate=%s' % ivy_compiler.isolate.get()
-        else:
-            st = sys.argv[1].replace(".ivy", '')
-            print>>fo, st
-        print>>fo
-        
-        print >>fo, len(self.pre)
-        for pre in self.pre:
-            var = self.pre2nex[pre]
-            if isinstance(var.sort, UnionSort):
-                sort = var.sort.sorts[0]
-            else:
-                sort = var.sort
-            if sort.dom:
-                st = "%d %s %s %s" % (len(sort.dom), sort.rng.get_vmt().upper(), var.name, ' '.join([s.get_vmt().upper() for s in sort.dom]))
-            else:
-                st = "0 %s %s" % (sort.name.upper(), var.name)
-            print >>fo, st
-
-        print >>fo
-        print >>fo, len(self.sorts)
-        for k in self.sorts:
-            print >> fo, k.upper(), self.sorts[k]
-        print >>fo
-        print >>fo, len(self.concretizations)
-        for k in self.concretizations:
-            print >>fo, k
         
     def process_sig(self):
         for name,sort in ivy_logic.sig.sorts.iteritems():
@@ -219,58 +147,89 @@ class print_module_vmt():
                 continue
             if isinstance(sort, lg.EnumeratedSort):
                 print >> sys.stderr, 'enumerated sort', sort.get_vmt(), type(sort)
+                assert False
                 n = len(sort.extension)
-                self.instance[name] = n
-                for i in range(n):
-                    for j in range(i):
-                        if sort.extension[i] in ivy_logic.sig.symbols and sort.extension[j] in ivy_logic.sig.symbols:
-                            self.axioms.append('(not (= %s_%s %s_%s))'% (sort.name, sort.extension[i], sort.name, sort.extension[j]))
+#                self.instance[name] = n
+#                for i in range(n):
+#                    for j in range(i):
+#                        if sort.extension[i] in ivy_logic.sig.symbols and sort.extension[j] in ivy_logic.sig.symbols:
+#                           self.axioms.append('(not (= %s_%s %s_%s))'% (sort.name, sort.extension[i], sort.name, sort.extension[j]))
             elif not isinstance(sort,UninterpretedSort):
-                print >> sys.stderr, 'not uninterpreted sort', sort.get_vmt(), type(sort), isinstance(sort, lg.EnumeratedSort)
                 assert False, "todo"
-            for i in range(2, 32):
-                if 2**i >= self.instance[name] and i not in self.used:
-                    break
-            self.used.add(i)
-            self.sorts[name] = i
-
-#        print >>sys.stderr, ivy_logic.sig.symbols
-        for name,sym in ivy_logic.sig.symbols.iteritems():
-#            print name, sym.sort
-            if isinstance(sym.sort,UnionSort):
-                print >> sys.stderr, "UnionSort", sym, sym.sort.sorts
-
-                for s in sym.sort.sorts:
-                    sym = lg.Const(sym.name, s)
-                    psym = sym.prefix('__')
-                    nsym = sym
-                    self.pre.add(psym)
-                    self.nex.add(nsym)
-                    self.pre2nex[psym] = nsym
-                    self.nex2pre[nsym] = psym
-                    self.allvars.add(psym)
-                    self.allvars.add(nsym)
+            res = ''
+            res += '(declare-sort {} 0)'.format(name)
+            self.sorts[sort] = 0
+            self.str[str(sort)] = res
             
-                    self.add_constant(sym, True)
-            else:
-                psym = sym.prefix('__')
-                nsym = sym
-                self.pre.add(psym)
-                self.nex.add(nsym)
-                self.pre2nex[psym] = nsym
-                self.nex2pre[nsym] = psym
-                self.allvars.add(psym)
-                self.allvars.add(nsym)
+        for name,sym in ivy_logic.sig.symbols.iteritems():
+            if isinstance(sym.sort, ivy_logic.UnionSort):
+                assert len(sym.sort.sorts) <= 1, 'Unkonwn Union Sort: %s %s' % (name, sym.sort)
+                if len(sym.sort.sorts) == 0:
+                    continue
+                sym = lg.Const(sym.name, sym.sort.sorts[0])
             
-                self.add_constant(sym, True)
+            psym = sym.prefix('__')
+            nsym = sym
+            self.pre.add(psym)
+            self.nex.add(nsym)
+            self.pre2nex[psym] = nsym
+            self.nex2pre[nsym] = psym
+            self.allvars.add(psym)
+            self.allvars.add(nsym)
+            self.add_constant(sym, True)       
     
     def process_defs(self):
+        self.process_defs_v2()
+
+    def process_defs_v0(self):
+        for lf in self.definitions:
+            f = lf.formula.to_constraint()
+            self.add_new_constants(f)
+            label = str(lf.label)
+            res = (f, label, "axiom", "true")
+            self.vmt[label] = res
+            self.defn_labels.append(label)
+            
+            pref = lgu.substitute(f, self.nex2pre)
+            self.add_new_constants(pref)
+            label = "__" + str(lf.label)
+            res = (pref, label, "axiom", "true")
+            self.vmt[label] = res
+            self.defn_labels.append(label)
+            
+    def process_defs_v1(self):
         for lf in self.definitions:
+#             print(type(lf.formula))
+#             print(lf.formula)
+            sym = lf.formula.defines()
+            label = str(sym)
+            lhs = lf.formula.lhs()
+            rhs = lf.formula.rhs()
+            self.add_new_constants(rhs)
+            args = []
+            if isinstance(lhs, lg.Apply):
+                for arg in lhs.terms:
+                    args.append(arg)
+            self.add_definition(label, sym, args, rhs)
+            
+            sym = lgu.substitute(sym, self.nex2pre)
+            label = str(sym)
+            lhs = lgu.substitute(lf.formula.lhs(), self.nex2pre)
+            rhs = lgu.substitute(lf.formula.rhs(), self.nex2pre)
+            self.add_new_constants(rhs)
+            args = []
+            if isinstance(lhs, lg.Apply):
+                for arg in lhs.terms:
+                    args.append(arg)
+            self.add_definition(label, sym, args, rhs)
+            self.pre.remove(sym)
+            self.defs.add(sym)
+            
+    def process_defs_v2(self):
+        for lf in self.definitions:
+#             print(type(lf.formula))
+#             print(lf.formula)
             sym = lf.formula.defines()
-            print >> sys.stderr, "def!", sym
-            print >> sys.stderr, lf
-            continue
-            assert False, "TODO"
             label = "def_" + str(sym)
             lhs = lf.formula.lhs()
             rhs = lf.formula.rhs()
@@ -278,19 +237,15 @@ class print_module_vmt():
 
             args = {}
             vargs = []
-            print lhs, rhs
-#            if isinstance(lhs, lg.Apply):
-#                for arg in lhs.terms:
-#                    name = "V" + str(len(vargs))
-#                    varg = lg.Var(name, arg.sort)
-#                    args[arg] = varg
-#                    vargs.append(varg)
-#                print args
-#                lhs = lgu.substitute(lhs, args)
-#                rhs = lgu.substitute(rhs, args)
+            if isinstance(lhs, lg.Apply):
+                for arg in lhs.terms:
+                    name = "V" + str(len(vargs))
+                    varg = lg.Var(name, arg.sort)
+                    args[arg] = varg
+                    vargs.append(varg)
+                lhs = lgu.substitute(lhs, args)
+                rhs = lgu.substitute(rhs, args)
             f = lg.Eq(lhs, rhs)
-            print f
-#            exit()
             if len(vargs) != 0:
                 f = lg.ForAll(vargs, f)
             res = (f, label, "definition", str(sym))
@@ -305,21 +260,36 @@ class print_module_vmt():
             self.defn_labels.append(label)
             
     def process_conj(self):
-        fmlas = [lf.formula for lf in self.mod.labeled_conjs]
+        fmlas = []
+        helpers = []
+        for lf in self.mod.labeled_conjs:
+            label = str(lf.label)
+            if label.startswith("help_"):
+                helpers.append(lf)
+            else:
+                fmlas.append(lf.formula)
         cl = lut.Clauses(fmlas)
         f = self.get_formula(cl)
         pref = lgu.substitute(f, self.nex2pre)
-        self.add_new_constants(pref, True)
-        pref = lgu.substitute(pref, self.nex2pre)
+        self.add_new_constants(pref, 'prop')
         res = (pref, "prop", "invar-property", "0")
         self.vmt["$prop"] = res
         
+        for lf in helpers:
+            label = str(lf.label)
+            self.helpers[label] = lf.formula
+            cl = lut.Clauses([lf.formula])
+            f = self.get_formula(cl)
+            pref = lgu.substitute(f, self.nex2pre)
+            self.add_new_constants(pref, 'prop')
+            res = (pref, label, "help", label)
+            self.vmt[label] = res
+        
     def process_axiom(self):
         fmlas = [lf.formula for lf in self.mod.labeled_axioms]
         cl = lut.Clauses(fmlas)
         f = self.get_formula(cl)
-        print >> sys.stderr, f
-        self.add_new_constants(f, True)
+        self.add_new_constants(f, 'axiom')
         res = (f, "axiom", "axiom", "true")
         self.vmt["$axiom"] = res
 
@@ -331,79 +301,71 @@ class print_module_vmt():
             history = ag.get_history(ag.states[0])
             post = lut.and_clauses(history.post)
             init_cl.append(post)
-        while len(init_cl) > 1:
-            if init_cl[0] == init_cl[1]:
-                init_cl = init_cl[1:]
         clauses = lut.and_clauses(*init_cl)
-#        print >> sys.stderr, clauses
         f = self.get_formula(clauses)
         pref = lgu.substitute(f, self.nex2pre)
-        self.add_new_constants(pref, True)
-        pref = lgu.substitute(f, self.nex2pre)
+        self.add_new_constants(pref, 'init')
         res = (pref, "init", "init", "true")
         self.vmt["$init"] = res
         
     def process_actions(self):
-#        print self.mod.public_actions
-        st = ivy_compiler.isolate.get().split('.')[0]
+        print >>sys.stderr, self.mod.public_actions
+        if ivy_compiler.isolate.get():
+            st = ivy_compiler.isolate.get().split('.')[0]
+        else:
+            st = ''
         st = [st, 'timeout', 'handle', 'recv']
         for name in self.mod.public_actions:
             print >>sys.stderr, name
-            if ivy_compiler.isolate.get() == None or any(s in name for s in st):
-                action = ia.env_action(name)
-#            print "action2: ", ia.action_def_to_str(name, action)
-                ag = ivy_art.AnalysisGraph()
-                pre = itp.State()
-                pre.clauses = lut.true_clauses()
-                with itp.EvalContext(check=False):
-                    post = ag.execute(action, pre)
-                history = ag.get_history(post)
-                clauses = lut.and_clauses(history.post)
-                f = self.get_formula(clauses)
-#                print >>sys.stderr, name, f
-                conjuncts = clauses.fmlas
-                defn = lut.close_epr(lg.And(*conjuncts))
+            if not (ivy_compiler.isolate.get() == None or any(s in name for s in st)):
+                continue
+            action = ia.env_action(name)
+#             print ("action2: ", ia.action_def_to_str(name, action))
+            ag = ivy_art.AnalysisGraph()
+            pre = itp.State()
+            pre.clauses = lut.true_clauses()
+#             print(pre.to_formula())
+            with itp.EvalContext(check=False):
+                post = ag.execute(action, pre)
+            history = ag.get_history(post)
+            clauses = lut.and_clauses(history.post)
+            f = self.get_formula(clauses)
+            conjuncts = clauses.fmlas
+            defn = lut.close_epr(lg.And(*conjuncts))
 #             print(defn)
 #             assert(0)
             
-                update = action.update(pre.domain,pre.in_scope)
-                sf = self.standardize_action(f, update[0], name)
-#            print >> sys.stderr, sf
-
-                copies = []
-                for var in self.nex:
-                    if var not in update[0]:
-                        copies += self.copy_constant(var)
-                self.add_new_constants(sf)
+            update = action.update(pre.domain,pre.in_scope)
+            sf = self.standardize_action(f, update[0], name)
+            self.add_new_constants(sf, 'action')
             
-                actname = ("action_" + name).replace(":", "_")
-                self.actions.add(actname)
-#            print 'result: ', res
-                self.vmt[actname] = ("(define-fun %s () Bool \n(and %s\n%s)\n)" % (actname, sf.instantiation(self.instance, {}), ' '.join(copies))).replace(":", "_")
-
-    def process_guarantee(self):
-        callgraph = defaultdict(list)
-        for actname,action in self.mod.actions.iteritems():
-            for called_name in action.iter_calls():
-                callgraph[called_name].append(actname)
-        for actname,action in self.mod.actions.iteritems():
-            guarantees = [sub for sub in action.iter_subactions() if isinstance(sub, (ia.AssertAction, ia.Ranking))]
-            if guarantees:
-                callers = callgraph[actname]
-                roots = set(iu.reachable([actname], lambda x: callgraph[x]))
-                for sub in guarantees:
-                    for root in roots:
-                        if root in self.mod.public_actions:
-                            action = ia.env_action(root)
-                            ag = ivy_art.AnalysisGraph()
-                            pre = itp.State()
-                            pre.clauses = lut.true_clauses()
-                            post = ag.execute(action,prestate=pre)
-                            fail = itp.State(expr = itp.fail_expr(post.expr))
-                            print post
-                            print fail
-        exit(0)
-
+            actname = "action_" + name
+            self.actions.add(actname)
+            res = (sf, actname, "action", name)
+            self.vmt[actname] = res
+
+    def process_global(self):
+        for n in self.nex:
+            if n not in self.updated:
+                self.glo.add(n)
+        subs = {}
+        for n in self.glo:
+            p = self.nex2pre[n]
+            subs[p] = n
+            if p in self.defs:
+                self.defn_labels.remove(str(p))
+            else:
+                self.pre.remove(p)
+            print p, type(p)
+            self.str.pop(str(p))
+            self.set_global(n, str(p)+str(n))
+#             print("\treplacing %s -> %s globally" % (p, n))
+        if len(subs) != 0:
+            for k, v in self.vmt.iteritems():
+                f, name, suffix, value = v
+                newF = lgu.substitute(f, subs)
+                self.vmt[k] = (newF, name, suffix, value)
+        
     def standardize_action(self, f, nexvars, name):
         nexSet = set()
         for n in nexvars:
@@ -412,148 +374,166 @@ class print_module_vmt():
 
         cons = lgu.used_constants(f)
         subs = dict()
+        evars = []
         for c in cons:
             if c in self.nex:
                 if c not in nexSet:
                     subs[c] = self.nex2pre[c]
-#        print >>sys.stderr, subs
-        if len(subs) == 0:
-            return f
-        else:
+#             elif False and (c not in self.pre):
+            elif c not in self.pre:
+                if (not c.sort.dom) and (c.sort != lg.Boolean):
+                    vname = "Vtmp"+c.name
+#                     vname = vname.replace(":", "")
+                    qv = lg.Var(vname, c.sort)
+                    subs[c] = qv
+                    evars.append(qv)
+        action = f
+        if len(subs) != 0:
 #            for k, v in subs.iteritems():
-#                 print("\treplacing %s -> %s in %s" % (k, v, name))
-            return lgu.substitute(f, subs)
+#                print("\treplacing %s -> %s in %s" % (k, v, name))
+            action = lgu.substitute(f, subs)
+        if len(evars) != 0:
+            action = lg.Exists(evars, action)
+        return action
+        
   
-    def add_new_constants(self, f, addPre = False):
+    def add_new_constants(self, f, origin = ''):
         cons = lgu.used_constants(f)
         for c in cons:
-            if c not in self.allvars and c.name != '>' and c.name != '>=' and c.name != '<=':
-                print >> sys.stderr, "local variable %s" % (c.name)
-                if addPre:
-                    psym = c.prefix("__")
-                    nsym = c
+            if c not in self.allvars and c.name not in {'<=', '>=', '>'}:
+                print >>sys.stderr, c, c.sort, origin
+                if origin in {'prop', 'axiom'}:
+                    sym = c
+                    psym = sym.prefix('__')
+                    nsym = sym
                     self.pre.add(psym)
                     self.nex.add(nsym)
                     self.pre2nex[psym] = nsym
                     self.nex2pre[nsym] = psym
                     self.allvars.add(psym)
                     self.allvars.add(nsym)
-                    print >> sys.stderr, '???', c, c.sort
+                    self.add_constant(sym, True)       
                 else:
+                    self.add_constant(c, False)
                     self.vars.add(c)
                     self.allvars.add(c)
-                    nsym = c
-
-                self.add_constant(nsym, addPre)
                 
     def add_constant(self, sym, addPre):   
-        if isinstance(sym.sort, UnionSort):
-            sort = sym.sort.sorts[0]
-        else:
-            sort = sym.sort
-        name = sym.get_vmt()
-        names = [name.replace(":", "_")]
+        sort = sym.sort
+        name = str(sym)
+        prefix = ''
+        prefix +=  '(declare-fun '
+            
+        suffix = ''
+        suffix += " ("
         if sort.dom:
-            for s in sort.dom:
-                tmp = []
-                for i in range(self.instance[s.get_vmt()]):
-                    tmp += ['%s%d_%s'%(s.get_vmt(), i, n) for n in names]
-                names = tmp
-        st = '(declare-fun %s ()'
+            suffix += ' '.join('{}'.format(s) for idx,s in enumerate(sort.dom))
+        suffix += ")"
         if not sort.is_relational():
-            st += ' {}_type)'.format(sort.rng.get_vmt())
-            self.axioms += ["(is_%s %s)" % (sort.rng.get_vmt(), n) for n in names]
+            suffix += ' {}'.format(sort.rng)
         else:
-            st += ' bool_type)'
-
-        self.nexstr[name] = '\n'.join([st%(n) for n in names])
-#        print name
-#        print self.str[name]
+            suffix += ' Bool'
+        suffix += ')'
+        self.str[name] = prefix + name + suffix
         
         if addPre:
             psym = self.nex2pre[sym]
-            prename = psym.get_vmt()
-            prenames = [prename.replace(":", '_')]
+            prename = str(psym)
+            prenex = ''
+            prenex +=  '(define-fun '
+            prenex +=  '.' + name
+            prenex += " ("
             if sort.dom:
-                for s in sort.dom:
-                    tmp = []
-                    for i in range(self.instance[s.get_vmt()]):
-                        tmp += ['%s%d_%s'%(s.get_vmt(), i, n) for n in prenames]
-                    prenames = tmp
-            self.prestr[prename] = '\n'.join([st%(n) for n in prenames])
-            
-            prenex = '(define-fun .%s ()'
+                prenex += ' '.join('(V{} {})'.format(idx, s) for idx,s in enumerate(sort.dom))
+            prenex += ")"
             if not sort.is_relational():
-                prenex += ' {}_type'.format(sort.rng.get_vmt())
+                prenex += ' {}'.format(sort.rng)
             else:
-                prenex += ' bool_type'
-            prenex += ' (! %s :next %s))'
-            self.prenexstr[prename+name] = '\n'.join([prenex%(n1, n1, n2) for n1, n2 in zip(prenames, names)])
-#            print prename, self.str[prename]
-#            print prename+name, self.str[prename+name]
+                prenex += ' Bool'
+            prenex += ' (! '
+            if sort.dom:
+                prenex += '(' + prename + ' '
+                prenex += ' '.join('V{}'.format(idx) for idx,s in enumerate(sort.dom))
+                prenex += ')'
+            else:
+                prenex += prename
+            prenex += ' :next ' + name + '))'
+            self.str[prename] = prefix + prename + suffix
+            self.str[prename+name] = prenex
+            
+    def add_definition(self, label, sym, args, rhs):   
+        sort = sym.sort
+        name = str(sym)
 
-    def copy_constant(self, sym):
-        ret = []
-        psym = self.nex2pre[sym]
-        names = [sym.get_vmt().replace(":", "_")]
-        prenames = [psym.get_vmt().replace(":", "_")]
-        if isinstance(sym.sort, UnionSort):
-            sort = sym.sort.sorts[0]
-        else:
-            sort = sym.sort
+        prenex = ''
+        prenex +=  name
+        prenex += " ("
         if sort.dom:
-            for s in sort.dom:
-                tmp    = []
-                pretmp = []
-                for i in range(self.instance[s.get_vmt()]):
-                    tmp    += ['%s%d_%s'%(s.get_vmt(), i, n) for n in names]
-                    pretmp += ['%s%d_%s'%(s.get_vmt(), i, n) for n in prenames]
-                names = tmp
-                prenames = pretmp
-        return ["(= %s %s)" % (name, prename) for name, prename in zip(names, prenames)]
+            prenex += ' '.join('({} {})'.format(args[idx], s) for idx,s in enumerate(sort.dom))
+        prenex += ")"
+        if not sort.is_relational():
+            prenex += ' {}'.format(sort.rng)
+        else:
+            prenex += ' Bool'
+        
+#         No annotation, value is the prenex
+        res = (rhs, label, "", prenex)
+        self.vmt[label] = res
+        self.defn_labels.append(label)
             
+    def set_global(self, sym, k):
+        sort = sym.sort
+        name = str(sym)
+        
+        prenex = ''
+        prenex +=  '(define-fun '
+        prenex +=  '.' + name
+        prenex += " ("
+        if sort.dom:
+            prenex += ' '.join('(V{} {})'.format(idx, s) for idx,s in enumerate(sort.dom))
+        prenex += ")"
+        if not sort.is_relational():
+            prenex += ' {}'.format(sort.rng)
+        else:
+            prenex += ' Bool'
+        prenex += ' (! '
+        if sort.dom:
+            prenex += '(' + name + ' '
+            prenex += ' '.join('V{}'.format(idx) for idx,s in enumerate(sort.dom))
+            prenex += ')'
+        else:
+            prenex += name
+        prenex += ' :global true))'
+        self.str[k] = prenex
+                    
     def get_formula(self, clauses):
         cl = lut.and_clauses(clauses)
         f = cl.to_formula()
-        rep = {}
-        for c in f:
-            if isinstance(c, lg.Eq) or isinstance(c, lg.Iff):
-#                print >>sys.stderr, 'here!!', type(c.t1), type(c.t2)
-#                print >>sys.stderr, c
-                for st in ['fml:', 'loc:', 'ts0_']:
-                    if isinstance(c.t1, lg.Const) and st in c.t1.name and (c.t1 not in rep or rep[c.t1] == c.t1):
-                        if c.t2 in rep:
-                            rep[c.t1] = rep[c.t2]
-                            break
-                        else:
-                            rep[c.t1] = c.t2
-                            break
-                    elif isinstance(c.t2, lg.Const) and st in c.t2.name and (c.t2 not in rep or rep[c.t2] == c.t2):
-                        if c.t1 in rep:
-                            rep[c.t2] = rep[c.t1]
-                            break
-                        else:
-                            rep[c.t2] = c.t1
-                            break
-#        print >>sys.stderr, rep
-#        print >>sys.stderr, f
-        return lgu.substitute(f, rep)
         return f
     
     def get_vmt_string(self, k):
-        f, name, suffix, value = self.vmt[k]
-        res = '(define-fun .' + name + ' () Bool (! \n'
-        res += f.instantiation(self.instance, {}).replace(":", "_")
-        res += '\n :' + suffix + ' ' + value + '))'
+        f, name, annot, value = self.vmt[k]
+        if annot != "":
+#            Has annotation
+            res = '(define-fun .' + name + ' () Bool (! \n'
+            res += ' (let (($v '
+            res += str(f)
+            res += '\n ))\n (and $v))'
+            res += '\n :' + annot + ' ' + value + '))'
+        else:
+#            No annotation, value is the prefix
+            res = '(define-fun ' + value + ' \n '
+            res += str(f)
+            res += '\n)'
         return res
     
-#    def get_vmt_string_def(self, k):
-#        f, name, prenex, value = self.vmt[k]
-#        
-#        res = prenex
-#        res += ' ' + str(f)
-#        res += '\n)'
-#        return res
+    def get_vmt_string_def(self, k):
+        f, name, prenex, value = self.vmt[k]
+        
+        res = prenex
+        res += ' ' + str(f)
+        res += '\n)'
+        return res
     
     def print_sort_size(self, name, sz):
         res = ''
@@ -562,7 +542,7 @@ class print_module_vmt():
         fprint(res)
     
 
-def print_isolate(inst):
+def print_isolate():
     temporals = [p for p in im.module.labeled_props if p.temporal]
     mod = im.module
     if temporals:
@@ -573,37 +553,31 @@ def print_isolate(inst):
         mod.concept_spaces = []
         mod.update_conjs()
 #     ifc.check_fragment()
-    print_module_vmt(mod, inst)
-
-def print_module(inst):
-    isolate = ivy_compiler.isolate.get()
-    if isolate != None:
-        isolates = [isolate]
-    else:
-        isolates = sorted(list(im.module.isolates))
-        if len(isolates) == 0:
-            isolates = [None]
-
-    if len(isolates) != 1:
-        raise iu.IvyError(None,"Expected exactly one isolate, got %s" % len(isolates))
+    print_module_vmt(mod)
 
+def print_module():
+    isolates = [ivy_compiler.isolate.get()] if ivy_compiler.isolate.get() else sorted(list(im.module.isolates))
+    done_isolates = 0
     for isolate in isolates:
         if isolate != None and isolate in im.module.isolates:
             idef = im.module.isolates[isolate]
             if len(idef.verified()) == 0 or isinstance(idef,ivy_ast.TrustedIsolateDef):
                 continue # skip if nothing to verify
         if isolate:
-                print >> sys.stderr, "\nPrinting isolate {}:".format(isolate)
+            print "\nPrinting isolate {}:".format(isolate)
+        if done_isolates >= 1:
+            raise iu.IvyError(None,"Expected exactly one isolate, got %s" % len(isolates))
         with im.module.copy():
             ivy_isolate.create_isolate(isolate) # ,ext='ext'
-            print_isolate(inst)
+            print_isolate()
+            done_isolates += 1
 
 def usage():
-    print >> sys.stderr, "usage: \n  {} file.ivy instance_specification".format(sys.argv[0])
+    print "usage: \n  {} file.ivy output.vmt".format(sys.argv[0])
     sys.exit(1)
 
-
 def main():
+    global outFile
     import signal
     signal.signal(signal.SIGINT,signal.SIG_DFL)
     import ivy_alpha
@@ -614,8 +588,9 @@ def main():
     with im.Module():
         with utl.ErrorPrinter():
             ivy_init.source_file(sys.argv[1],ivy_init.open_read(sys.argv[1]),create_isolate=False)
-            print_module(sys.argv[2])
-    print >> sys.stderr, "OK"
+            outFile = sys.argv[2]
+            print_module()
+    print "OK"
 
 
 if __name__ == "__main__":
diff --git a/ivy/logic.py b/ivy/logic.py
index e37c6e6..6438422 100644
--- a/ivy/logic.py
+++ b/ivy/logic.py
@@ -22,15 +22,12 @@ class UninterpretedSort(recstruct('UninterpretedSort', ['name'], [])):
     __slots__ = ()
     def __str__(self):
         return self.name
-    def get_vmt(self):
-        return self.name
+
 
 class BooleanSort(recstruct('BooleanSort', [], [])):
     __slots__ = ()
     def __str__(self):
         return 'Boolean'
-    def get_vmt(self):
-        return 'Boolean'
 
 Boolean = BooleanSort()
 
@@ -59,7 +56,7 @@ class EnumeratedSort(recstruct('EnumeratedSort', ['name','extension'], [])):
         return name,extension
     def __str__(self):
         return '{' + ','.join(self.extension) + '}'
-    def get_vmt(self):
+    def __vmt__(self):
         return self.name
     @property
     def constructors(self):
@@ -122,14 +119,7 @@ class Var(recstruct('Var', ['name', 'sort'], [])):
         return self.name
     def __call__(self, *terms):
         return Apply(self, *terms) if len(terms) > 0 else self
-    def instantiation(self, instances, replace):
-        if self.name == '0' or self.name == '__0':
-            assert False, "0 is not a var"
-        if self.name in replace:
-            return replace[self.name]
-        assert isinstance(self.sort, FunctionSort), "Function var?"
-        return '%s_%s' % (self.sort.get_vmt(), self.name)
-        return '%s_%s' % ('_'.join(str(s) for s in self.sort.domain), self.name)
+
 
 class Const(recstruct('Const', ['name', 'sort'], [])):
     __slots__ = ()
@@ -140,20 +130,15 @@ class Const(recstruct('Const', ['name', 'sort'], [])):
         return name, sort
     def __str__(self):
         return self.name
-    def get_vmt(self):
-        if not isinstance(self.sort, FunctionSort): 
-            return '%s_%s' % (self.sort.get_vmt(), self.name)
-        else:
-            return '%s_%s' % ('_'.join(s.get_vmt() for s in self.sort.domain), self.name)
     def __call__(self, *terms):
         return Apply(self, *terms) if len(terms) > 0 else self
-    def instantiation(self, instances, replace):
-        if self.name in replace:
-            assert False, "replace constant?"
-        if isinstance(self.sort, BooleanSort):
-            return "(= %s bv_true)" % (self.get_vmt())
+    def __vmt__(self):
+        if self.name in {'0', '__0'}:
+            return "{}_{}".format(self.sort, self.name)
+        if self.name in {'<', '__<', '-', '__-'}:
+            return "{}_{}".format(self.sort.domain[0], self.name)
         else:
-            return self.get_vmt()
+            return self.name
 
 
 def report_bad_sort(op,position,expected,got):
@@ -191,75 +176,23 @@ class Apply(recstruct('Apply', [], ['func', '*terms'])):
                 str(self.func),
                 ', '.join(str(t) for t in self.terms)
             )
-    def get_vmt(self):
+    def __vmt__(self):
         if len(self.terms) == 0:
-            return self.func.get_vmt()
-        else:
-            if self.func.name == '>':
-                return '({} {} {})'.format(self.func.get_vmt().replace('>', '<', 1),
-                        self.terms[1], self.terms[0]
-                        )
-            elif self.func.name == '>=':
-                return '(not ({} {} {}))'.format(self.func.get_vmt().replace('>=', '<', 1),
-                        self.terms[0], self.terms[1]
-                        )
-            elif self.func.name == '<=':
-                return '(not ({} {} {}))'.format(self.func.get_vmt().replace('<=', '<', 1),
-                            self.terms[1], self.terms[0]
-                            )
-            else:
-                return '({} {})'.format(
-                    self.func.get_vmt(),
-                    ' '.join(t.get_vmt() for t in self.terms)
-                        )
-
-    def instantiation(self, instances, replace):
-        name = self.func.name
-        terms = self.terms
-
-        if self.func.name == '>':
-            name = '__<'
-            terms = (terms[1], terms[0])
-        elif self.func.name == '>=':
-            name = '__<'
-        elif self.func.name == '<=':
-            name = '__<'
-            terms = (terms[1], terms[0])
-        name = '%s_%s' % ('_'.join(s.get_vmt() for s in self.func.sort.domain), name)
-
-        args = [[]]
-        for term in terms:
-            if isinstance(term, Var) and term.name in replace:
-                args = map(lambda a: a + [(None, replace[term.name])], args)
-            else:
-                newargs = []
-                st = term.instantiation(instances, replace)
-                for j in range(instances[term.sort.name]):
-                    newargs += map(lambda x: x + [(st, "%s%d" % (term.sort.name, j))], args)
-                args = newargs
-        ret = ''
-        for arg in args:
-            st = name
-            cond = []
-            for i in range(len(arg)):
-                st = '%s_%s' % (arg[i][1], st)
-                if arg[i][0]:
-                    cond.append('(= %s %s)' % (arg[i][0], arg[i][1]))
-            if cond:
-                if arg != args[-1]:
-                    ret = '%s(ite (and %s) %s ' % (ret, ' '.join(cond), st)
-                else:
-                    ret = '%s%s' % (ret, st) + ')' * (len(args) - 1)
-            else:
-                ret = st
-        if isinstance(self.func.sort.range, BooleanSort):
-            ret = "(= %s bv_true)" % ret
-        else: 
-            ret = ret
-        if self.func.name == '>=' or self.func.name == '<=':
-            return '(not %s)' % ret
+            return str(self.func)
         else:
-            return ret
+            name = str(self.func)
+            if name == '<':
+                return '({}_< {} {})'.format(self.func.sort.omain[0], self.terms[0], self.terms[1])
+            elif name == '>':
+                return '({}_< {} {})'.format(self.func.sort.domain[0], self.terms[1], self.terms[0])
+            elif name == '<=':
+                return '(not ({}_< {} {}))'.format(self.func.sort.domain[0], self.terms[1], self.terms[0])
+            elif name == '>=':
+                return '(not ({}_< {} {}))'.format(self.func.sort.domain[0], self.terms[0], self.terms[1])
+            return '({} {})'.format(
+                name,
+                ' '.join(str(t) for t in self.terms)
+            )
 
     sort = property(lambda self: TopS if self.func.sort == TopS else
                     self.func.sort.range)
@@ -279,10 +212,8 @@ class Eq(recstruct('Eq', [], ['t1', 't2'])):
         return t1, t2
     def __str__(self):
         return '({} == {})'.format(self.t1, self.t2)
-    def get_vmt(self):
-        return '(= {} {})'.format(self.t1.get_vmt(), self.t2.get_vmt())
-    def instantiation(self, instances, replace):
-        return "(= %s %s)" % (self.t1.instantiation(instances, replace), self.t2.instantiation(instances, replace))
+    def __vmt__(self):
+        return '(= {} {})'.format(self.t1, self.t2)
 
 
 # Ite expressions must be given a sort, as otherwise contructing trees of
@@ -307,10 +238,8 @@ class Ite(recstruct('Ite', ['sort'], ['cond', 't_then', 't_else'])):
         return sort, cond, t_then, t_else
     def __str__(self):
         return 'Ite({}, {}, {})'.format(self.cond, self.t_then, self.t_else)
-    def get_vmt(self):
-        return '(ite {} {} {})'.format(self.cond.get_vmt(), self.t_then.get_vmt(), self.t_else.get_vmt())
-    def instantiation(self, instances, replace):
-        return "(ite %s %s %s)" % (self.cond.instantiation(instances, replace), self.t_then.instantiation(instances, replace), self.t_else.instantiation(instances, replace))
+    def __vmt__(self):
+        return '(ite {} {} {})'.format(self.cond, self.t_then, self.t_else)
 
 
 class Not(recstruct('Not', [], ['body'])):
@@ -326,10 +255,8 @@ class Not(recstruct('Not', [], ['body'])):
             return '({} != {})'.format(self.body.t1, self.body.t2)
         else:
             return 'Not({})'.format(self.body)
-    def get_vmt(self):
-        return '(not {})'.format(self.body.get_vmt())
-    def instantiation(self, instances, replace):
-        return '(not %s)' % (self.body.instantiation(instances, replace))
+    def __vmt__(self):
+        return '(not {})'.format(self.body)
 
 
 class Globally(recstruct('Globally', ['environ'], ['body'])):
@@ -378,18 +305,13 @@ class And(recstruct('And', [], ['*terms'])):
         return 'And({})'.format(
             ', '.join(str(t) for t in self)
         )
-    def get_vmt(self):
+    def __vmt__(self):
         if len(self) == 1:
-            return '{}'.format(' '.join(t.get_vmt() for t in self))
+            return '{}'.format(' '.join(str(t) for t in self))
         elif len(self) == 0:
             return 'true'
         else:
-            return '(and {})'.format(' '.join(t.get_vmt() for t in self))
-    def instantiation(self, instances, replace):
-        if len(self) == 0:
-            return '(= bv_true bv_true)'
-        else:
-            return '(and %s)' % (' '.join([t.instantiation(instances, replace) for t in self]))
+            return '(and {})'.format(' '.join(str(t) for t in self))
 
 
 class Or(recstruct('Or', [], ['*terms'])):
@@ -410,18 +332,13 @@ class Or(recstruct('Or', [], ['*terms'])):
         return 'Or({})'.format(
             ', '.join(str(t) for t in self)
         )
-    def get_vmt(self):
+    def __vmt__(self):
         if len(self) == 1:
-            return '{}'.format(' '.join(t.get_vmt() for t in self))
+            return '{}'.format(' '.join(str(t) for t in self))
         elif len(self) == 0:
             return 'false'
         else:
-            return '(or {})'.format(' '.join(t.get_vmt() for t in self))
-    def instantiation(self, instances, replace):
-        if len(self) == 0:
-            return '(= bv_false bv_true)'
-        else:
-            return '(or %s)' % (' '.join([t.instantiation(instances, replace) for t in self]))
+            return '(or {})'.format(' '.join(str(t) for t in self))
 
 
 class Implies(recstruct('Implies', [], ['t1', 't2'])):
@@ -438,10 +355,8 @@ class Implies(recstruct('Implies', [], ['t1', 't2'])):
         return t1, t2
     def __str__(self):
         return 'Implies({}, {})'.format(self.t1, self.t2)
-    def get_vmt(self):
-        return '(=> {} {})'.format(self.t1.get_vmt(), self.t2.get_vmt())
-    def instantiation(self, instances, replace):
-        return "(=> %s %s)" % (self.t1.instantiation(instances, replace), self.t2.instantiation(instances, replace))
+    def __vmt__(self):
+        return '(=> {} {})'.format(self.t1, self.t2)
 
 
 class Iff(recstruct('Iff', [], ['t1', 't2'])):
@@ -458,15 +373,9 @@ class Iff(recstruct('Iff', [], ['t1', 't2'])):
         return t1, t2
     def __str__(self):
         return 'Iff({}, {})'.format(self.t1, self.t2)
-    def get_vmt(self):
-        return '(= {} {})'.format(self.t1.get_vmt(), self.t2.get_vmt())
-    def instantiation(self, instances, replace):
-        return "(= %s %s)" % (self.t1.instantiation(instances, replace), self.t2.instantiation(instances, replace))
+    def __vmt__(self):
+        return '(= {} {})'.format(self.t1, self.t2)
 
-def update_dict(dic, var, value):
-    tmp = dict(dic)
-    tmp[var.name] = "%s%d" % (var.sort.name, value)
-    return tmp
 
 class ForAll(recstruct('ForAll', ['variables'], ['body'])):
     __slots__ = ()
@@ -484,18 +393,11 @@ class ForAll(recstruct('ForAll', ['variables'], ['body'])):
         return '(ForAll {}. {})'.format(
             ', '.join('{}:{}'.format(v.name, v.sort) for v in sorted(self.variables)),
             self.body)
-    def get_vmt(self):
+    def __vmt__(self):
         return '(forall ({}) {})'.format(
-            ' '.join('({} {})'.format(v.get_vmt(), v.sort.get_vmt()) for v in sorted(self.variables)),
+            ' '.join('({} {})'.format(v.name, v.sort) for v in sorted(self.variables)),
             self.body)
-    def instantiation(self, instances, replace):
-        reps = [replace]
-        for v in self.variables:
-            newlist = []
-            for i in range(instances[v.sort.get_vmt()]):
-                newlist += [update_dict(dic, v, i) for dic in reps]
-            reps = newlist
-        return "(and %s)" % (' '.join([self.body.instantiation(instances, rep) for rep in reps]))
+
 
 class Exists(recstruct('Exists', ['variables'], ['body'])):
     __slots__ = ()
@@ -513,18 +415,10 @@ class Exists(recstruct('Exists', ['variables'], ['body'])):
         return '(Exists {}. {})'.format(
             ', '.join('{}:{}'.format(v.name, v.sort) for v in sorted(self.variables)),
             self.body)
-    def get_vmt(self):
+    def __vmt__(self):
         return '(exists ({}) {})'.format(
-            ' '.join('({} {})'.format(v.get_vmt(), v.sort.get_vmt()) for v in sorted(self.variables)),
+            ' '.join('({} {})'.format(v.name, v.sort) for v in sorted(self.variables)),
             self.body)
-    def instantiation(self, instances, replace):
-        reps = [replace]
-        for v in self.variables:
-            newlist = []
-            for i in range(instances[v.sort.get_vmt()]):
-                newlist += [update_dict(dic, v, i) for dic in reps]
-            reps = newlist
-        return "(or %s)" % (' '.join([self.body.instantiation(instances, rep) for rep in reps]))
 
 
 class Lambda(recstruct('Lambda', ['variables'], ['body'])):
